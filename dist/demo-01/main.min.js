(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

var _WebGL = _interopRequireDefault(require("./modules/WebGL"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

window.onload = function () {
  var $canvas = document.getElementById('canvas');
  var webgl = new _WebGL["default"]($canvas);
  window.addEventListener('resize', webgl.resize.bind(webgl));
};

},{"./modules/WebGL":2}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _output = _interopRequireDefault(require("./glsl/output.vert"));

var _output2 = _interopRequireDefault(require("./glsl/output.frag"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Webgl =
/*#__PURE__*/
function () {
  function Webgl($canvas) {
    _classCallCheck(this, Webgl);

    this.$canvas = $canvas; // this.windowSize = [window.innerWidth, window.innerHeight];

    this.windowSize = [window.innerWidth, window.innerHeight];
    this.$canvas.width = this.windowSize[0];
    this.$canvas.height = this.windowSize[1];
    this.gl = this.$canvas.getContext('webgl') || $canvas.getContext('experimental-webgl');
    this.resize();
    this.uniforms = {
      time: {
        value: 0,
        location: null,
        type: 'f'
      },
      resolution: {
        value: this.windowSize,
        location: null,
        type: 'v2'
      }
    };
    this.init();
  }

  _createClass(Webgl, [{
    key: "init",
    value: function init() {
      this.program = this.createProgram(this.createShader(_output["default"], 'vertex'), this.createShader(_output2["default"], 'fragment'));

      for (var key in this.uniforms) {
        this.uniforms[key].location = this.gl.getUniformLocation(this.program, key);
      }

      var position = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
      var index = [0, 2, 1, 1, 2, 3];
      var vPosition = this.createVbo(position);
      var vIndex = this.createIbo(index);
      var vAttLocation = this.gl.getAttribLocation(this.program, 'position');
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vPosition);
      this.gl.enableVertexAttribArray(vAttLocation);
      this.gl.vertexAttribPointer(vAttLocation, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vIndex);
      this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
      this.startTime = new Date().getTime();
      this.render();
    }
  }, {
    key: "createShader",
    value: function createShader(text, type) {
      var shader;

      switch (type) {
        case 'vertex':
          shader = this.gl.createShader(this.gl.VERTEX_SHADER);
          break;

        case 'fragment':
          shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
          break;

        default:
          return;
      }

      this.gl.shaderSource(shader, text);
      this.gl.compileShader(shader);

      if (this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        return shader;
      } else {
        console.error(this.gl.getShaderInfoLog(shader));
        console.warn(this.gl.getShaderInfoLog(shader));
      }
    }
  }, {
    key: "createProgram",
    value: function createProgram(vertex, fragment) {
      var program = this.gl.createProgram();
      this.gl.attachShader(program, vertex);
      this.gl.attachShader(program, fragment);
      this.gl.linkProgram(program);

      if (this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        this.gl.useProgram(program);
        return program;
      } else {
        return null;
      }
    }
  }, {
    key: "createVbo",
    value: function createVbo(data) {
      var vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      return vbo;
    }
  }, {
    key: "createIbo",
    value: function createIbo(data) {
      var ibo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, ibo);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
      return ibo;
    }
  }, {
    key: "render",
    value: function render() {
      this.uniforms.time.value = (new Date().getTime() - this.startTime) * 0.002;
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.setUniforms();
      this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
      this.gl.flush();
      requestAnimationFrame(this.render.bind(this));
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      for (var key in this.uniforms) {
        var uniform = this.uniforms[key];

        switch (uniform.type) {
          case 'f':
            this.gl.uniform1f(uniform.location, uniform.value);
            break;

          case 'v2':
            this.gl.uniform2fv(uniform.location, uniform.value);
            break;
        }
      }
    }
  }, {
    key: "resize",
    value: function resize() {
      this.windowSize[0] = window.innerWidth;
      this.windowSize[1] = window.innerHeight;
      this.$canvas.width = this.windowSize[0];
      this.$canvas.height = this.windowSize[1];
      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    }
  }]);

  return Webgl;
}();

exports["default"] = Webgl;

},{"./glsl/output.frag":3,"./glsl/output.vert":4}],3:[function(require,module,exports){
module.exports = "precision mediump float;\r\nuniform float time;\r\nuniform vec2 resolution;\r\n// uniform vec2  mouse;\r\n\r\nconst vec3 center = vec3(0.0);\r\nconst float radius = 1.0;\r\nconst vec3 light_position = vec3(2.0, -5.0, 3.0);\r\n\r\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\r\n{\r\n    return length(p - c) - r;\r\n}\r\n\r\nfloat map_the_world(in vec3 p)\r\n{\r\n    const float disS = 4.0;\r\n    float displacement = sin(disS * p.x + time) * sin(disS * p.y + time) * sin(disS * p.z + time) * 0.25;\r\n    float sphere_0 = distance_from_sphere(p, center, radius);\r\n\r\n    // Later we might have sphere_1, sphere_2, cube_3, etc...\r\n\r\n    return sphere_0 + displacement;\r\n}\r\n\r\nvec3 calculate_normal(in vec3 p)\r\n{\r\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\r\n\r\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\r\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\r\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\r\n\r\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\r\n\r\n    return normalize(normal);\r\n}\r\n\r\nvec3 ray_march(in vec3 ro, in vec3 rd)\r\n{\r\n    float total_distance_traveled = 0.0;\r\n    const int NUMBER_OF_STEPS = 32;\r\n    const float MINIMUM_HIT_DISTANCE = 0.01;\r\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\r\n\r\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\r\n    {\r\n        vec3 current_position = ro + total_distance_traveled * rd;\r\n\r\n        float distance_to_closest = map_the_world(current_position);\r\n\r\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \r\n        {\r\n            // return vec3(1.0, 0.0, 0.0);\r\n            vec3 normal = calculate_normal(current_position);\r\n\r\n            vec3 direction_to_light = normalize(current_position - light_position);\r\n\r\n            // Remember, each component of the normal will be in \r\n            // the range -1..1, so for the purposes of visualizing\r\n            // it as an RGB color, let's remap it to the range\r\n            // 0..1\r\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\r\n\r\n            return mix(vec3(1.0, 0.95, 0.9), vec3(1.0, 0.8, 1.0), diffuse_intensity);\r\n        }\r\n\r\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\r\n        {\r\n            break;\r\n        }\r\n        total_distance_traveled += distance_to_closest;\r\n    }\r\n    return vec3(1.0);\r\n}\r\n\r\nvoid main(void){\r\n\r\n  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\r\n\r\n\r\n  vec3 camera_position = vec3(0.0, 0.0, -3.0);\r\n  vec3 ro = camera_position;  // ray's origin\r\n  vec3 rd = vec3(p, 1.0);  // ray's direction\r\n\r\n  vec3 shaded_color = ray_march(ro, rd);\r\n\r\n  gl_FragColor = vec4(shaded_color, 1.0);\r\n\r\n}";

},{}],4:[function(require,module,exports){
module.exports = "attribute vec3 position;\r\n\r\nvoid main(){\r\n  gl_Position = vec4(position, 1.0);\r\n}";

},{}]},{},[1]);
