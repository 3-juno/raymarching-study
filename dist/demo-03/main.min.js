(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Mouse =
/*#__PURE__*/
function () {
  function Mouse(prop) {
    _classCallCheck(this, Mouse);

    this.prop = prop;
    this.mouseMove = this._mouseMove.bind(this);
    this._mousePos = [0, 0];
    this.mousePos = [0, 0];
    this.prop.$canvas.addEventListener('mousemove', this.mouseMove.bind(this), false);
  }

  _createClass(Mouse, [{
    key: "_mouseMove",
    value: function _mouseMove(e) {
      e.preventDefault();
      var x = e.clientX;
      var y = e.clientY;
      x = x / window.innerWidth;
      y = 1 - y / window.innerHeight;
      x = x * 2 - 1;
      y = y * 2 - 1;
      this._mousePos[0] = x;
      this._mousePos[1] = y;
    }
  }, {
    key: "render",
    value: function render() {
      this.mousePos[0] += (this._mousePos[0] - this.mousePos[0]) * 0.1;
      this.mousePos[1] += (this._mousePos[1] - this.mousePos[1]) * 0.1;
    }
  }]);

  return Mouse;
}();

exports["default"] = Mouse;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _commonFunc = _interopRequireDefault(require("./glsl/common-func.frag"));

var _Mouse = _interopRequireDefault(require("./Mouse"));

var _Wheel = _interopRequireDefault(require("./Wheel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var WebGL =
/*#__PURE__*/
function () {
  function WebGL(props) {
    _classCallCheck(this, WebGL);

    this.props = props;
    this.$canvas = props.$canvas; // this.windowSize = [window.innerWidth, window.innerHeight];

    this.windowSize = [window.innerWidth, window.innerHeight];
    this.$canvas.width = this.windowSize[0];
    this.$canvas.height = this.windowSize[1];
    this.gl = this.$canvas.getContext('webgl', {
      antialias: false
    });
    this.resize();
    this.mouse = new _Mouse["default"]({
      $canvas: this.$canvas
    });
    this.wheel = new _Wheel["default"]();
    var self = this;
    this.uniforms = _objectSpread({
      time: {
        value: 0,
        location: null,
        type: 'f'
      },
      resolution: {
        value: this.windowSize,
        location: null,
        type: 'v2'
      },
      mouse: {
        value: this.mouse.mousePos,
        location: null,
        type: 'v2'
      },
      wheel: {
        get value() {
          return self.wheel.wheel;
        },

        location: null,
        type: 'f'
      }
    }, props.uniforms);
    this.init();
  }

  _createClass(WebGL, [{
    key: "init",
    value: function init() {
      var fragment = _commonFunc["default"] + this.props.fragmentShader;
      this.program = this.createProgram(this.createShader(this.props.vertexShader, 'vertex'), this.createShader(fragment, 'fragment'));

      for (var key in this.uniforms) {
        this.uniforms[key].location = this.gl.getUniformLocation(this.program, key);
      }

      var position = [-1.0, 1.0, 0.0, 1.0, 1.0, 0.0, -1.0, -1.0, 0.0, 1.0, -1.0, 0.0];
      var index = [0, 2, 1, 1, 2, 3];
      var vPosition = this.createVbo(position);
      var vIndex = this.createIbo(index);
      var vAttLocation = this.gl.getAttribLocation(this.program, 'position');
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vPosition);
      this.gl.enableVertexAttribArray(vAttLocation);
      this.gl.vertexAttribPointer(vAttLocation, 3, this.gl.FLOAT, false, 0, 0);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vIndex);
      this.gl.clearColor(1.0, 1.0, 1.0, 1.0);
      this.startTime = new Date().getTime();
      this.render();
    }
  }, {
    key: "createShader",
    value: function createShader(text, type) {
      var shader;

      switch (type) {
        case 'vertex':
          shader = this.gl.createShader(this.gl.VERTEX_SHADER);
          break;

        case 'fragment':
          shader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
          break;

        default:
          return;
      }

      this.gl.shaderSource(shader, text);
      this.gl.compileShader(shader);

      if (this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
        return shader;
      } else {
        console.warn('gl.getShaderInfoLog()', type === this.gl.VERTEX_SHADER ? 'vertex' : 'fragment', this.gl.getShaderInfoLog(shader), this.addLineNumbers(text));
      }
    }
  }, {
    key: "addLineNumbers",
    value: function addLineNumbers(string) {
      var lines = string.split('\n');

      for (var i = 0; i < lines.length; i++) {
        lines[i] = i + 1 + ': ' + lines[i];
      }

      return lines.join('\n');
    }
  }, {
    key: "createProgram",
    value: function createProgram(vertex, fragment) {
      var program = this.gl.createProgram();
      this.gl.attachShader(program, vertex);
      this.gl.attachShader(program, fragment);
      this.gl.linkProgram(program);

      if (this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        this.gl.useProgram(program);
        return program;
      } else {
        return null;
      }
    }
  }, {
    key: "createVbo",
    value: function createVbo(data) {
      var vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
      return vbo;
    }
  }, {
    key: "createIbo",
    value: function createIbo(data) {
      var ibo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, ibo);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Int16Array(data), this.gl.STATIC_DRAW);
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
      return ibo;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms() {
      for (var key in this.uniforms) {
        var uniform = this.uniforms[key];

        switch (uniform.type) {
          case 'f':
            this.gl.uniform1f(uniform.location, uniform.value);
            break;

          case 'v2':
            this.gl.uniform2fv(uniform.location, uniform.value);
            break;

          case 'v3':
            this.gl.uniform3fv(uniform.location, uniform.value);
            break;

          case 'v4':
            this.gl.uniform4fv(uniform.location, uniform.value);
            break;
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      this.mouse.render();
      this.wheel.render();
    }
  }, {
    key: "resize",
    value: function resize() {
      this.windowSize[0] = window.innerWidth;
      this.windowSize[1] = window.innerHeight;
      this.$canvas.width = this.windowSize[0];
      this.$canvas.height = this.windowSize[1];
      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
    }
  }]);

  return WebGL;
}();

exports["default"] = WebGL;

},{"./Mouse":1,"./Wheel":3,"./glsl/common-func.frag":4}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Wheel =
/*#__PURE__*/
function () {
  function Wheel() {
    var _this = this;

    _classCallCheck(this, Wheel);

    this._wheel = 0;
    this.wheel = 0;
    window.addEventListener("wheel", function (e) {
      _this._wheel += e.deltaY;
    });
  }

  _createClass(Wheel, [{
    key: "render",
    value: function render() {
      this.wheel += (this._wheel - this.wheel) * 0.2;
    }
  }]);

  return Wheel;
}();

exports["default"] = Wheel;

},{}],4:[function(require,module,exports){
module.exports = "precision mediump float;\r\n\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform vec2 mouse;\r\nuniform float wheel;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nmat4 rotateY(float theta) {\r\n    float c = cos(theta);\r\n    float s = sin(theta);\r\n\r\n    return mat4(\r\n        vec4(c, 0, s, 0),\r\n        vec4(0, 1, 0, 0),\r\n        vec4(-s, 0, c, 0),\r\n        vec4(0, 0, 0, 1)\r\n    );\r\n}\r\n\r\n\r\n\r\nfloat sdSphere(in vec3 p, in vec3 c, float r)\r\n{\r\n    return length(p - c) - r;\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 c, vec3 b )\r\n{\r\n  vec3 d = abs(p - c) - b;\r\n  return length(max(d,0.0))\r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \r\n}\r\n\r\nfloat sdRoundBox( vec3 p, vec3 c, vec3 b, float r )\r\n{\r\n  vec3 d = abs(p - c) - b;\r\n  return length(max(d,0.0)) - r\r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \r\n}\r\n\r\nfloat unite( float a, float b){return min(a, b);}\r\nfloat subtract( float a, float b ){ return max(-a, b); }\r\nfloat intersect( float a, float b ){ return max(a, b); }\r\n\r\nfloat smoothUnion_h(float d1, float d2, float k) {\r\n    return clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n}\r\n\r\nfloat smoothUnion( float d1, float d2, float k ) {\r\n    float h = smoothUnion_h(d1, d2, k);\r\n    return mix( d2, d1, h ) - k*h*(1.0-h); \r\n}\r\n\r\nfloat smoothSubtraction( float d1, float d2, float k ) {\r\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\r\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \r\n}\r\n\r\nfloat smoothIntersection( float d1, float d2, float k ) {\r\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\r\n    return mix( d2, d1, h ) + k*h*(1.0-h); \r\n}";

},{}],5:[function(require,module,exports){
"use strict";

var _WebGL = _interopRequireDefault(require("./modules/WebGL"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

window.onload = function () {
  var $canvas = document.getElementById('canvas');
  var webgl = new _WebGL["default"]($canvas);
  window.addEventListener('resize', webgl.resize.bind(webgl));
};

},{"./modules/WebGL":6}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _output = _interopRequireDefault(require("./glsl/output.vert"));

var _output2 = _interopRequireDefault(require("./glsl/output.frag"));

var _WebGL3 = _interopRequireDefault(require("../../common/WebGL"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Webgl =
/*#__PURE__*/
function (_WebGL2) {
  _inherits(Webgl, _WebGL2);

  function Webgl($canvas) {
    _classCallCheck(this, Webgl);

    var uniforms = {};
    return _possibleConstructorReturn(this, _getPrototypeOf(Webgl).call(this, {
      $canvas: $canvas,
      uniforms: uniforms,
      vertexShader: _output["default"],
      fragmentShader: _output2["default"]
    }));
  }

  _createClass(Webgl, [{
    key: "render",
    value: function render() {
      _get(_getPrototypeOf(Webgl.prototype), "render", this).call(this);

      this.uniforms.time.value = (new Date().getTime() - this.startTime) * 0.002;
      this.gl.clear(this.gl.COLOR_BUFFER_BIT);
      this.setUniforms();
      this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
      this.gl.flush();
      requestAnimationFrame(this.render.bind(this));
    }
  }, {
    key: "resize",
    value: function resize() {
      _get(_getPrototypeOf(Webgl.prototype), "resize", this).call(this);
    }
  }]);

  return Webgl;
}(_WebGL3["default"]);

exports["default"] = Webgl;

},{"../../common/WebGL":2,"./glsl/output.frag":7,"./glsl/output.vert":8}],7:[function(require,module,exports){
module.exports = "\r\nconst vec3 center = vec3(0.0);\r\nconst float radius = 1.0;\r\nconst vec3 light_position = vec3(2000.0, -5000.0, 3000.0);\r\n\r\nconst vec3 bgColor = vec3(0.9, 0.8, 1.0);\r\n\r\nvec3 trans(vec3 p){\r\n    float interval = 6.0;\r\n    return mod(p, interval) - interval/2.0;\r\n}\r\n\r\nfloat sdSphere_repeat(in vec3 p, in vec3 c, float r)\r\n{\r\n    return length(trans(p - c)) - r;\r\n}\r\n\r\nfloat sdRoundBox_repeat( vec3 p, vec3 c, vec3 b, float r )\r\n{\r\n  vec3 d = abs(trans(p - c)) - b;\r\n  return length(max(d,0.0)) - r\r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \r\n}\r\n\r\nfloat expFog(float d, float density) {\r\n\tfloat dd = d * density;\r\n\treturn exp(-dd * dd);\r\n}\r\n\r\nfloat mapTheWorld(in vec3 p)\r\n{\r\n    const float disS = 2.0;\r\n    vec3 samplePoint = p;\r\n    // samplePoint = (rotateY(time) * vec4(samplePoint, 1.0)).xyz;\r\n    \r\n    \r\n    float displacement = sin(disS * p.x + time) * sin(disS * p.y + time) * sin(disS * p.z + time) * 0.2;\r\n    // displacement *= sin(time) * 0.5 + 0.5;\r\n    float sphere_0 = \r\n    // sdRoundBox_repeat(samplePoint, center, vec3(0.7, 0.7, 0.7), 0.4);\r\n    sdSphere_repeat(samplePoint, center, radius);\r\n\r\n    return sphere_0 + displacement;\r\n}\r\n\r\nvec3 calculateNormal(in vec3 p)\r\n{\r\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\r\n\r\n    float gradient_x = mapTheWorld(p + small_step.xyy) - mapTheWorld(p - small_step.xyy);\r\n    float gradient_y = mapTheWorld(p + small_step.yxy) - mapTheWorld(p - small_step.yxy);\r\n    float gradient_z = mapTheWorld(p + small_step.yyx) - mapTheWorld(p - small_step.yyx);\r\n\r\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\r\n\r\n    return normalize(normal);\r\n}\r\n\r\nvec3 rayMarch(in vec3 ro, in vec3 rd)\r\n{\r\n    float total_distance_traveled = 0.0;\r\n    const int NUMBER_OF_STEPS = 64;\r\n    const float MINIMUM_HIT_DISTANCE = 0.01;\r\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\r\n\r\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\r\n    {\r\n        vec3 current_position = ro + total_distance_traveled * rd;\r\n\r\n        float distance_to_closest = mapTheWorld(current_position);\r\n\r\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \r\n        {\r\n            // return vec3(1.0, 0.0, 0.0);\r\n            vec3 normal = calculateNormal(current_position);\r\n\r\n            vec3 direction_to_light = normalize(current_position - light_position);\r\n\r\n            // Remember, each component of the normal will be in \r\n            // the range -1..1, so for the purposes of visualizing\r\n            // it as an RGB color, let's remap it to the range\r\n            // 0..1\r\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\r\n\r\n            vec3 color = mix(vec3(1.0, 0.92, 0.88), vec3(1.0, 0.75, 0.95), diffuse_intensity);\r\n\r\n            float fog_intensity = expFog(total_distance_traveled, 0.03);\r\n\r\n            color = mix(bgColor, color, fog_intensity);\r\n\r\n            return color;\r\n        }\r\n\r\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\r\n        {\r\n            break;\r\n        }\r\n        total_distance_traveled += distance_to_closest;\r\n    }\r\n    return bgColor;\r\n}\r\n\r\nvoid main(void){\r\n\r\n  vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\r\n\r\n\r\n  vec3 camera_position = vec3(mouse * 1.0, -3.0 - wheel * 0.01 + time);\r\n  vec3 ro = camera_position;  // ray's origin\r\n  vec3 rd = normalize(vec3(p, 1.0));  // ray's direction\r\n\r\n  vec3 shaded_color = rayMarch(ro, rd);\r\n\r\n  gl_FragColor = vec4(shaded_color, 1.0);\r\n\r\n}";

},{}],8:[function(require,module,exports){
module.exports = "attribute vec3 position;\r\n\r\nvoid main(){\r\n  gl_Position = vec4(position, 1.0);\r\n}";

},{}]},{},[5]);
